This patch reverts https://trac.sagemath.org/ticket/24531 which atm requires an
alpha release of Pari to build Sage

--- a/build/pkgs/ratpoints/SPKG.txt
+++ b/build/pkgs/ratpoints/SPKG.txt
@@ -5,10 +5,6 @@
 Michael Stoll's program which searches for rational points on hyperelliptic
 curves.
 
-NOTE: the ratpoints package has been assimilated by PARI/GP. Therefore,
-this package (as Sage package) is deprecated. In the future, it will be
-removed from Sage.
-
 == Upstream Contact ==
 
  * Author: Michael Stoll
--- a/src/sage/libs/pari/convert_gmp.pyx
+++ b/src/sage/libs/pari/convert_gmp.pyx
@@ -62,9 +62,6 @@
     For internal use only; this directly uses the PARI stack.
     One should call ``sig_on()`` before and ``sig_off()`` after.
     """
-    if mpz_sgn(value) == 0:
-        return gen_0
-
     cdef unsigned long limbs = mpz_size(value)
 
     cdef GEN z = cgeti(limbs + 2)
--- a/src/sage/libs/ratpoints.pyx
+++ b/src/sage/libs/ratpoints.pyx
@@ -1,22 +1,11 @@
 r"""
-Hyperelliptic Curve Point Finding, via ratpoints (deprecated)
-
-This module is deprecated, use PARI instead::
-
-    sage: pari(EllipticCurve("389a1")).ellratpoints(4)
-    [[-2, 0], [-2, -1], [-1, 1], [-1, -2], [0, 0], [0, -1], [1, 0], [1, -1], [3, 5], [3, -6], [4, 8], [4, -9], [-3/4, 7/8], [-3/4, -15/8]]
-    sage: pari("[x^3 + x^2 - 2*x, 1]").hyperellratpoints(4)
-    [[-2, 0], [-2, -1], [-1, 1], [-1, -2], [0, 0], [0, -1], [1, 0], [1, -1], [3, 5], [3, -6], [4, 8], [4, -9], [-3/4, 7/8], [-3/4, -15/8]]
+Hyperelliptic Curve Point Finding, via ratpoints.
 """
-
 from __future__ import print_function
 
 from cysignals.memory cimport sig_malloc, sig_realloc, sig_free
 from cysignals.signals cimport sig_on, sig_off
 
-from sage.misc.superseded import deprecation
-deprecation(24531, "the module sage.libs.ratpoints is deprecated; use pari.ellratpoints or pari.hyperellratpoints instead")
-
 
 cdef int process(long x, long z, mpz_t y, void *info0, int *quit):
     # ratpoints calls this function when it finds a point [x : y : z]
@@ -71,8 +60,6 @@
     EXAMPLES::
 
         sage: from sage.libs.ratpoints import ratpoints
-        doctest:...: DeprecationWarning: the module sage.libs.ratpoints is deprecated; use pari.ellratpoints or pari.hyperellratpoints instead
-        See http://trac.sagemath.org/24531 for details.
         sage: for x,y,z in ratpoints([1..6], 200):
         ....:     print(-1*y^2 + 1*z^6 + 2*x*z^5 + 3*x^2*z^4 + 4*x^3*z^3 + 5*x^4*z^2 + 6*x^5*z)
         0
--- a/src/sage/schemes/elliptic_curves/descent_two_isogeny.pyx
+++ b/src/sage/schemes/elliptic_curves/descent_two_isogeny.pyx
@@ -29,15 +29,16 @@
 from sage.libs.flint.fmpz_poly cimport *
 from sage.libs.flint.nmod_poly cimport *
 from sage.libs.flint.ulong_extras cimport *
+from sage.libs.ratpoints cimport ratpoints_mpz_exists_only
 
-from cypari2.paridecl cimport (GEN, cgetg, t_POL, set_gel, gel, stoi, lg,
-        evalvarn, evalsigne, Z_issquare, hyperellratpoints)
-from cypari2.stack cimport clear_stack
-from sage.libs.pari.convert_gmp cimport _new_GEN_from_mpz_t
-
-
-DEF N_RES_CLASSES_BSD = 10
+cdef int N_RES_CLASSES_BSD = 10
 
+cdef unsigned long ui0 = <unsigned long>0
+cdef unsigned long ui1 = <unsigned long>1
+cdef unsigned long ui2 = <unsigned long>2
+cdef unsigned long ui3 = <unsigned long>3
+cdef unsigned long ui4 = <unsigned long>4
+cdef unsigned long ui8 = <unsigned long>8
 
 cdef unsigned long valuation(mpz_t a, mpz_t p):
     """
@@ -96,16 +97,16 @@
     if mpz_sgn(a) == 0: return 1
 
     v = valuation(a,p)
-    if v & 1: return 0
+    if v&(ui1): return 0
 
     mpz_init_set(aa,a)
     while v:
         v -= 1
         mpz_divexact(aa, aa, p)
-    if mpz_cmp_ui(p, 2)==0:
-        result = (mpz_fdiv_ui(aa, 8) == 1)
+    if mpz_cmp_ui(p, ui2)==0:
+        result = ( mpz_fdiv_ui(aa,ui8)==ui1 )
     else:
-        result = (mpz_legendre(aa, p) == 1)
+        result = ( mpz_legendre(aa,p)==1 )
     mpz_clear(aa)
     return result
 
@@ -153,10 +154,10 @@
 
     mpz_init_set(g_prime_of_x, x)
     mpz_mul(g_prime_of_x, a, x)
-    mpz_mul_ui(g_prime_of_x, g_prime_of_x, 4)
-    mpz_addmul_ui(g_prime_of_x, b, 3)
+    mpz_mul_ui(g_prime_of_x, g_prime_of_x, ui4)
+    mpz_addmul_ui(g_prime_of_x, b, ui3)
     mpz_mul(g_prime_of_x, g_prime_of_x, x)
-    mpz_addmul_ui(g_prime_of_x, c, 2)
+    mpz_addmul_ui(g_prime_of_x, c, ui2)
     mpz_mul(g_prime_of_x, g_prime_of_x, x)
     mpz_add(g_prime_of_x, g_prime_of_x, d)
 
@@ -199,18 +200,18 @@
 
     mpz_init_set(g_prime_of_x, x)
     mpz_mul(g_prime_of_x, a, x)
-    mpz_mul_ui(g_prime_of_x, g_prime_of_x, 4)
-    mpz_addmul_ui(g_prime_of_x, b, 3)
+    mpz_mul_ui(g_prime_of_x, g_prime_of_x, ui4)
+    mpz_addmul_ui(g_prime_of_x, b, ui3)
     mpz_mul(g_prime_of_x, g_prime_of_x, x)
-    mpz_addmul_ui(g_prime_of_x, c, 2)
+    mpz_addmul_ui(g_prime_of_x, c, ui2)
     mpz_mul(g_prime_of_x, g_prime_of_x, x)
     mpz_add(g_prime_of_x, g_prime_of_x, d)
 
     lambd = valuation(g_of_x, p)
     mpz_init_set(g_of_x_odd_part, g_of_x)
     while mpz_even_p(g_of_x_odd_part):
-        mpz_divexact_ui(g_of_x_odd_part, g_of_x_odd_part, 2)
-    g_of_x_odd_part_mod_4 = mpz_fdiv_ui(g_of_x_odd_part, 4)
+        mpz_divexact_ui(g_of_x_odd_part, g_of_x_odd_part, ui2)
+    g_of_x_odd_part_mod_4 = mpz_fdiv_ui(g_of_x_odd_part, ui4)
     if mpz_sgn(g_prime_of_x)==0:
         if lambd >= 2*nu: result = 0 # undecided
         elif lambd == 2*nu-2 and g_of_x_odd_part_mod_4==1:
@@ -220,9 +221,9 @@
         if lambd > 2*mu: result = +1 # soluble
         elif nu > mu:
             if lambd >= mu+nu: result = +1 # soluble
-            elif lambd+1 == mu+nu and (lambd & 1) == 0:
+            elif lambd+1 == mu+nu and lambd&ui1==0:
                 result = +1 # soluble
-            elif lambd+2 == mu+nu and (lambd & 1) == 0 and g_of_x_odd_part_mod_4 == 1:
+            elif lambd+2 == mu+nu and lambd&ui1==0 and g_of_x_odd_part_mod_4==1:
                 result = +1 # soluble
         else: # nu <= mu
             if lambd >= 2*nu: result = 0 # undecided
@@ -246,7 +247,7 @@
     cdef unsigned long t
     cdef mpz_t s
 
-    if mpz_cmp_ui(p, 2) == 0:
+    if mpz_cmp_ui(p, ui2)==0:
         code = lemma7(a,b,c,d,e,x_k,p,k)
     else:
         code = lemma6(a,b,c,d,e,x_k,p,k)
@@ -288,16 +289,16 @@
 
     # Step 0: divide out all common p from the quartic
     v_min = valuation(a, pp)
-    if mpz_cmp_ui(b, 0) != 0:
+    if mpz_cmp_ui(b, ui0) != 0:
         v = valuation(b, pp)
         if v < v_min: v_min = v
-    if mpz_cmp_ui(c, 0) != 0:
+    if mpz_cmp_ui(c, ui0) != 0:
         v = valuation(c, pp)
         if v < v_min: v_min = v
-    if mpz_cmp_ui(d, 0) != 0:
+    if mpz_cmp_ui(d, ui0) != 0:
         v = valuation(d, pp)
         if v < v_min: v_min = v
-    if mpz_cmp_ui(e, 0) != 0:
+    if mpz_cmp_ui(e, ui0) != 0:
         v = valuation(e, pp)
         if v < v_min: v_min = v
     for 0 <= v < v_min:
@@ -328,7 +329,7 @@
             return 1
 
         nmod_poly_zero(f)
-        nmod_poly_set_coeff_ui(f, 0, 1)
+        nmod_poly_set_coeff_ui(f, 0, ui1)
         for i from 0 <= i < f_factzn.num:
             for j from 0 <= j < (f_factzn.exp[i]>>1):
                 nmod_poly_mul(f, f, &f_factzn.p[i])
@@ -365,7 +366,7 @@
             rr = nmod_poly_get_coeff_ui(f, 0)
             ss = rr*qq
             mpz_set(ddd,d)
-            mpz_sub_ui(ddd, ddd, ss*2)
+            mpz_sub_ui(ddd, ddd, ss*ui2)
             mpz_set(eee,e)
             mpz_sub_ui(eee, eee, ss*rr)
         elif i == 2: # g == x^2 + rr*x + ss
@@ -374,14 +375,14 @@
             mpz_init(tt)
             mpz_set_ui(tt, rr*qq)
             mpz_set(bbb,b)
-            mpz_submul_ui(bbb, tt, 2)
+            mpz_submul_ui(bbb, tt, ui2)
             mpz_set(ccc,c)
             mpz_submul_ui(ccc, tt, rr)
             ss = nmod_poly_get_coeff_ui(f, 0)
             mpz_set_ui(tt, ss*qq)
             mpz_set(eee,e)
             mpz_submul_ui(eee, tt, ss)
-            mpz_mul_ui(tt, tt, 2)
+            mpz_mul_ui(tt, tt, ui2)
             mpz_sub(ccc, ccc, tt)
             mpz_set(ddd,d)
             mpz_submul_ui(ddd, tt, rr)
@@ -521,16 +522,16 @@
 
     # Step 0: divide out all common p from the quartic
     v_min = valuation(a, pp)
-    if mpz_cmp_ui(b, 0) != 0:
+    if mpz_cmp_ui(b, ui0) != 0:
         v = valuation(b, pp)
         if v < v_min: v_min = v
-    if mpz_cmp_ui(c, 0) != 0:
+    if mpz_cmp_ui(c, ui0) != 0:
         v = valuation(c, pp)
         if v < v_min: v_min = v
-    if mpz_cmp_ui(d, 0) != 0:
+    if mpz_cmp_ui(d, ui0) != 0:
         v = valuation(d, pp)
         if v < v_min: v_min = v
-    if mpz_cmp_ui(e, 0) != 0:
+    if mpz_cmp_ui(e, ui0) != 0:
         v = valuation(e, pp)
         if v < v_min: v_min = v
     for 0 <= v < v_min:
@@ -611,7 +612,7 @@
             mpz_init(tt)
             mpz_mul(tt, rr, qq)
             mpz_set(bbb,b)
-            mpz_submul_ui(bbb, tt, 2)
+            mpz_submul_ui(bbb, tt, ui2)
             mpz_set(ccc,c)
             mpz_submul(ccc, tt, rr)
             A = Integer(f[0])
@@ -619,7 +620,7 @@
             mpz_mul(tt, ss, qq)
             mpz_set(eee,e)
             mpz_submul(eee, tt, ss)
-            mpz_mul_ui(tt, tt, 2)
+            mpz_mul_ui(tt, tt, ui2)
             mpz_sub(ccc, ccc, tt)
             mpz_set(ddd,d)
             mpz_submul(ddd, tt, rr)
@@ -821,7 +822,7 @@
     """
     cdef mpz_t zero
     cdef int result = 0
-    mpz_init_set_ui(zero, 0)
+    mpz_init_set_ui(zero, ui0)
     if Zp_soluble_BSD(a,b,c,d,e,zero,p,0):
         result = 1
     elif Zp_soluble_BSD(e,d,c,b,a,zero,p,1):
@@ -901,7 +902,7 @@
             return 0
 
     # Q2 soluble:
-    mpz_init_set_ui(mpz_2, 2)
+    mpz_init_set_ui(mpz_2, ui2)
     if not Qp_soluble(a,b,c,d,e,mpz_2):
         mpz_clear(mpz_2)
         return 0
@@ -922,9 +923,10 @@
     EXAMPLES::
 
         sage: from sage.schemes.elliptic_curves.descent_two_isogeny import test_els
+        sage: from sage.libs.ratpoints import ratpoints
         sage: for _ in range(1000):
         ....:     a,b,c,d,e = randint(1,1000), randint(1,1000), randint(1,1000), randint(1,1000), randint(1,1000)
-        ....:     if pari.Pol([a,b,c,d,e]).hyperellratpoints(1000, 1):
+        ....:     if len(ratpoints([e,d,c,b,a], 1000)) > 0:
         ....:         try:
         ....:             if not test_els(a,b,c,d,e):
         ....:                 print("This never happened", a, b, c, d, e)
@@ -947,11 +949,13 @@
     cdef Integer a_Int, c_Int, e_Int
     cdef mpz_t c_sq_mpz, d_prime_mpz
     cdef mpz_t n_divisors, j
+    cdef mpz_t *coeffs_ratp
+
 
     mpz_init(c_sq_mpz)
     mpz_mul(c_sq_mpz, c_mpz, c_mpz)
     mpz_init_set(d_prime_mpz, c_sq_mpz)
-    mpz_submul_ui(d_prime_mpz, d_mpz, 4)
+    mpz_submul_ui(d_prime_mpz, d_mpz, ui4)
     check_negs = 0
     if mpz_sgn(d_prime_mpz) > 0:
         if mpz_sgn(c_mpz) >= 0 or mpz_cmp(c_sq_mpz, d_prime_mpz) <= 0:
@@ -964,9 +968,15 @@
     cdef mpz_t *coeffs = <mpz_t *> sig_malloc(5 * sizeof(mpz_t))
     for i from 0 <= i <= 4:
         mpz_init(coeffs[i])
-    mpz_set_ui(coeffs[1], 0)     #
-    mpz_set(coeffs[2], c_mpz)    # These never change
-    mpz_set_ui(coeffs[3], 0)     #
+    mpz_set_ui(coeffs[1], ui0)     #
+    mpz_set(coeffs[2], c_mpz)      # These never change
+    mpz_set_ui(coeffs[3], ui0)     #
+
+    if not selmer_only:
+        # allocate space for ratpoints
+        coeffs_ratp = <mpz_t *> sig_malloc(5 * sizeof(mpz_t))
+        for i from 0 <= i <= 4:
+            mpz_init(coeffs_ratp[i])
 
     # Get prime divisors, and put them in an mpz_t array
     # (this block, by setting check_negs, takes care of
@@ -982,15 +992,15 @@
         mpz_init(p_div_d_mpz[n_primes])
         mpz_set_si(p_div_d_mpz[n_primes], -1)
         n_primes += 1
-    mpz_init_set_ui(n_divisors, 1)
+    mpz_init_set_ui(n_divisors, ui1)
     mpz_mul_2exp(n_divisors, n_divisors, n_primes)
 
-    mpz_init_set_ui(j, 0)
+    mpz_init_set_ui(j, ui0)
     if not selmer_only:
-        mpz_set_ui(n1, 0)
-    mpz_set_ui(n2, 0)
+        mpz_set_ui(n1, ui0)
+    mpz_set_ui(n2, ui0)
     while mpz_cmp(j, n_divisors) < 0:
-        mpz_set_ui(coeffs[4], 1)
+        mpz_set_ui(coeffs[4], ui1)
         for i from 0 <= i < n_primes:
             if mpz_tstbit(j, i):
                 mpz_mul(coeffs[4], coeffs[4], p_div_d_mpz[i])
@@ -1002,15 +1012,19 @@
         if not selmer_only:
             if verbose:
                 print("\nCalling ratpoints for small point search")
-            found_global_points = ratpoints_mpz_exists_only(coeffs, 4, global_limit_small)
+            for i from 0 <= i <= 4:
+                mpz_set(coeffs_ratp[i], coeffs[i])
+            sig_on()
+            found_global_points = ratpoints_mpz_exists_only(coeffs_ratp, global_limit_small, 4, verbose)
+            sig_off()
             if found_global_points:
                 if verbosity > 2:
                     a_Int = Integer(0); mpz_set(a_Int.value, coeffs[4])
                     c_Int = Integer(0); mpz_set(c_Int.value, coeffs[2])
                     e_Int = Integer(0); mpz_set(e_Int.value, coeffs[0])
                     print('Found small global point, quartic (%d,%d,%d,%d,%d)'%(a_Int,0,c_Int,0,e_Int))
-                mpz_add_ui(n1, n1, 1)
-                mpz_add_ui(n2, n2, 1)
+                mpz_add_ui(n1, n1, ui1)
+                mpz_add_ui(n2, n2, ui1)
             if verbose:
                 print("\nDone calling ratpoints for small point search")
         if not found_global_points:
@@ -1026,18 +1040,26 @@
                     c_Int = Integer(0); mpz_set(c_Int.value, coeffs[2])
                     e_Int = Integer(0); mpz_set(e_Int.value, coeffs[0])
                     print('ELS without small global points, quartic (%d,%d,%d,%d,%d)'%(a_Int,0,c_Int,0,e_Int))
-                mpz_add_ui(n2, n2, 1)
+                mpz_add_ui(n2, n2, ui1)
                 if not selmer_only:
                     if verbose:
                         print("\nCalling ratpoints for large point search")
-                    found_global_points = ratpoints_mpz_exists_only(coeffs, 4, global_limit_large)
+                    for i from 0 <= i <= 4:
+                        mpz_set(coeffs_ratp[i], coeffs[i])
+                    sig_on()
+                    found_global_points = ratpoints_mpz_exists_only(coeffs_ratp, global_limit_large, 4, verbose)
+                    sig_off()
                     if found_global_points:
                         if verbosity > 2:
                             print('  -- Found large global point.')
-                        mpz_add_ui(n1, n1, 1)
+                        mpz_add_ui(n1, n1, ui1)
                     if verbose:
                         print("\nDone calling ratpoints for large point search")
-        mpz_add_ui(j, j, 1)
+        mpz_add_ui(j, j, ui1)
+    if not selmer_only:
+        for i from 0 <= i <= 4:
+            mpz_clear(coeffs_ratp[i])
+        sig_free(coeffs_ratp)
     mpz_clear(j)
     for i from 0 <= i < n_primes:
         mpz_clear(p_div_d_mpz[i])
@@ -1183,13 +1205,13 @@
     cdef bint found, too_big, d_neg, d_prime_neg
     cdef n_factor_t fact
     cdef list primes
-    mpz_init_set(c_mpz, c.value)
-    mpz_init_set(d_mpz, d.value)
-    mpz_init(c_prime_mpz)
-    mpz_init(d_prime_mpz)
+    mpz_init_set(c_mpz, c.value)      #
+    mpz_init_set(d_mpz, d.value)      #
+    mpz_init(c_prime_mpz)             #
+    mpz_init(d_prime_mpz)             #
     mpz_mul_si(c_prime_mpz, c_mpz, -2)
     mpz_mul(d_prime_mpz, c_mpz, c_mpz)
-    mpz_submul_ui(d_prime_mpz, d_mpz, 4)
+    mpz_submul_ui(d_prime_mpz, d_mpz, ui4)
 
     d_neg = 0
     d_prime_neg = 0
@@ -1202,13 +1224,13 @@
     if mpz_fits_ulong_p(d_mpz) and mpz_fits_ulong_p(d_prime_mpz):
         # Factor very quickly using FLINT.
         p_list_mpz = <mpz_t *> sig_malloc(20 * sizeof(mpz_t))
-        mpz_init_set_ui(p_list_mpz[0], 2)
+        mpz_init_set_ui(p_list_mpz[0], ui2)
         p_list_len = 1
         n_factor_init(&fact)
         n_factor(&fact, mpz_get_ui(d_mpz), proof)
         for i from 0 <= i < fact.num:
             p = fact.p[i]
-            if p != 2:
+            if p != ui2:
                 mpz_init_set_ui(p_list_mpz[p_list_len], p)
                 p_list_len += 1
         n_factor(&fact, mpz_get_ui(d_prime_mpz), proof)
@@ -1281,36 +1303,3 @@
     return n1, n2, n1_prime, n2_prime
 
 
-cdef bint ratpoints_mpz_exists_only(mpz_t *coeffs, long degree, long H) except -1:
-    """
-    Search for projective points on the hyperelliptic curve
-    ``y^2 = P(x)``.
-
-    INPUT:
-
-    - ``coeffs`` -- an array of length ``degree + 1`` giving the
-      coefficients of ``P``, starting with the constant coefficient
-
-    - ``degree`` -- degree of ``P``
-
-    - ``H`` -- bound on the naive height for search
-
-    OUTPUT: boolean, whether or not a projective point was found
-    """
-    sig_on()
-    cdef GEN pol = cgetg(degree + 3, t_POL)
-    pol[1] = evalvarn(0) + evalsigne(1)
-    cdef long i
-    for i in range(degree + 1):
-        set_gel(pol, i+2, _new_GEN_from_mpz_t(coeffs[i]))
-
-    # PARI checks only for affine points, so we manually check for
-    # points at infinity (of the smooth model)
-    cdef int r
-    if degree % 2 == 1 or Z_issquare(gel(pol, degree+2)):
-        r = 1
-    else:
-        R = hyperellratpoints(pol, stoi(H), 1)
-        r = (lg(R) > 1)
-    clear_stack()
-    return r
--- a/src/sage/schemes/elliptic_curves/ell_rational_field.py
+++ b/src/sage/schemes/elliptic_curves/ell_rational_field.py
@@ -91,7 +91,7 @@
 from sage.functions.log import log
 
 import sage.matrix.all as matrix
-from sage.libs.pari.all import pari
+from   sage.libs.pari.all import pari, PariError
 from sage.functions.gamma import gamma_inc
 from math import sqrt
 from sage.interfaces.all import gp
@@ -2766,13 +2766,14 @@
 
         -  ``verbose (bool)`` - (default: ``False``)
 
-           If ``True``, report on the saturation process.
+           If ``True``, report on each point as found together with linear
+           relations between the points found and the saturation process.
 
            If ``False``, just return the result.
 
         -  ``rank_bound (bool)`` - (default: ``None``)
 
-           If provided, stop saturating once we find this many
+           If provided, stop searching for points once we find this many
            independent nontorsion points.
 
         OUTPUT: points (list) - list of independent points which generate
@@ -2785,19 +2786,19 @@
            the running time to increase by a factor of approximately
            4.5 (=exp(1.5)).
 
-        IMPLEMENTATION: Uses Michael Stoll's ratpoints module in PARI/GP.
+        IMPLEMENTATION: Uses Michael Stoll's ratpoints library.
 
         EXAMPLES::
 
             sage: E = EllipticCurve('389a1')
             sage: E.point_search(5, verbose=False)
-            [(-1 : 1 : 1), (0 : 0 : 1)]
+            [(-1 : 1 : 1), (-3/4 : 7/8 : 1)]
 
         Increasing the height_limit takes longer, but finds no more
         points::
 
             sage: E.point_search(10, verbose=False)
-            [(-1 : 1 : 1), (0 : 0 : 1)]
+            [(-1 : 1 : 1), (-3/4 : 7/8 : 1)]
 
         In fact this curve has rank 2 so no more than 2 points will ever be
         output, but we are not using this fact.
@@ -2805,7 +2806,7 @@
         ::
 
             sage: E.saturation(_)
-            ([(-1 : 1 : 1), (0 : 0 : 1)], 1, 0.152460177943144)
+            ([(-1 : 1 : 1), (-3/4 : 7/8 : 1)], 1, 0.152460177943144)
 
         What this shows is that if the rank is 2 then the points listed do
         generate the Mordell-Weil group (mod torsion). Finally,
@@ -2819,19 +2820,32 @@
 
             sage: E.point_search(5, verbose=False, rank_bound=1)
             [(-2 : 0 : 1)]
-        """
-        # Convert logarithmic height to height
-        # max(|p|,|q|) <= H, if x = p/q coprime
-        H = pari.exp(height_limit).floor()
 
+        """
+        from sage.libs.ratpoints import ratpoints
+        from sage.functions.all import exp
+        from sage.arith.all import GCD
+        H = exp(float(height_limit)) # max(|p|,|q|) <= H, if x = p/q coprime
+        coeffs = [16*self.b6(), 8*self.b4(), self.b2(), 1]
         points = []
-        for x, y in self.pari_curve().ellratpoints(H):
-            P = self((x, y, 1))
-            points.append(P)
-            if rank_bound is not None:
-                points = self.saturation(points, verbose=verbose)[0]
-                if len(points) >= rank_bound:
-                    return points
+        a1 = self.a1()
+        a3 = self.a3()
+        new_H = H*2 # since we change the x-coord by 2 below
+        for X,Y,Z in ratpoints(coeffs, new_H, verbose):
+            if Z == 0: continue
+            z = 2*Z
+            x = X/2
+            y = (Y/z - a1*x - a3*z)/2
+            d = GCD((x,y,z))
+            x = x/d
+            if max(x.numerator().abs(), x.denominator().abs()) <= H:
+                y = y/d
+                z = z/d
+                points.append(self((x,y,z)))
+                if rank_bound is not None:
+                    points = self.saturation(points, verbose=verbose)[0]
+                    if len(points) == rank_bound:
+                        break
         if rank_bound is None:
             points = self.saturation(points, verbose=verbose)[0]
         return points
@@ -5717,11 +5731,8 @@
 
             sage: E = EllipticCurve([0, 0, 1, -7, 6])
             sage: xset = E.integral_x_coords_in_interval(-100,100)
-            sage: sorted(xset)
+            sage: xlist = list(xset); xlist.sort(); xlist
             [-3, -2, -1, 0, 1, 2, 3, 4, 8, 11, 14, 21, 37, 52, 93]
-            sage: xset = E.integral_x_coords_in_interval(-100, 0)
-            sage: sorted(xset)
-            [-3, -2, -1, 0]
 
         TESTS:
 
@@ -5731,15 +5742,12 @@
             sage: E.integral_points()
             [(0 : 0 : 1), (2 : 1 : 1)]
         """
-        xmin = pari(xmin)
-        xmax = pari(xmax)
-        H = max(1, abs(xmin), abs(xmax))
-        S = set()
-        for pt in self.pari_curve().ellratpoints([H, 1]):
-            x = pt[0]
-            if xmin <= x <= xmax:
-                S.add(ZZ(x))
-        return S
+        from sage.libs.ratpoints import ratpoints
+        xmin=Integer(xmin)
+        xmax=Integer(xmax)
+        coeffs = self.division_polynomial(2).coefficients(sparse=False)
+        H = max(1, xmin.abs(), xmax.abs())
+        return set([x for x,y,z in ratpoints(coeffs, H, max_x_denom=1, intervals=[[xmin,xmax]]) if z])
 
     prove_BSD = BSD.prove_BSD
 
